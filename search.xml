<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ArrayList工作原理及实现]]></title>
      <url>http://Tyorofurin.github.io/2016/10/28/2016/10/ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Java开发人员对于ArrayList都很熟悉，工作中几乎每天都在使用它。本文对于ArrayList内部的实现的原理进行详细的说明。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>动态数组实现了List接口。有所有的线性表的操作，允许包括null在内的所有的实例。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。(该类基本上等同于Vector，除了它不是同步的。)</p>
</blockquote>
<p>ArrayList是动态数组，简单的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">list.add(<span class="string">"克罗斯"</span>);</div><div class="line">list.add(<span class="string">"格列兹曼"</span>);</div><div class="line">list.add(<span class="string">"罗本"</span>);</div><div class="line">list.remove(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</div><div class="line">list.add(<span class="string">"test"</span>);</div><div class="line">&#125;</div><div class="line">list.add(<span class="string">"扩容"</span>);</div></pre></td></tr></table></figure>
<p>ArrayList内部是维护一个数组，add和remove操作都是对数组的操作，操作过程如下图：</p>
<p><img src="/images/2016/10/图10.28-ArrayList工作原理及实现-操作演示.png" alt="图10.28-ArrayList工作原理及实现-操作演示"></p>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要两个操作：</p>
<p>＊ 扩容<br>＊ 新的对象放在在数组最后，计数加一</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>ArrayList最重要的一点就是扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="comment">/** 扩容到原来大小的1.5倍*/</span></div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="comment">/** 扩容的容量小于需要的大小,设置为需要的大小*/</span></div><div class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        <span class="comment">/** 判断又没有超过最大的数组长度限制*/</span></div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        <span class="comment">/**将原来数组的值copy新数组中去， ArrayList的引用指向新数组*/</span></div><div class="line">        <span class="comment">/**Arrays.copyOf会新创建newCapacity大小的数组，再拷贝原数组到新的数组。如果数据量很大，重复的创建的数组，那么还是会影响效率，*/</span></div><div class="line">        <span class="comment">/**因此鼓励在合适的时候通过构造方法指定默认的capaticy大小*/</span></div><div class="line">        <span class="comment">/** minCapacity is usually close to size, so this is a win:*/</span></div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>移除此列表中指定位置上的元素。向左移动所有后续元素（将其索引减 1）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Memory Management]]></title>
      <url>http://Tyorofurin.github.io/2016/10/19/Java%20Memory%20Management/</url>
      <content type="html"><![CDATA[<p>Java 内存管理，使用内置的垃圾回收器，是Java语言的亮点之一。它使开发者创建对象时不再担心内存的分配与回收， 因为垃圾回收器自动的回收内存来重新的使用。当消除内存泄露和其他内存相关的问题，使得用更少的代码加快开发成为可能。至少在理论上是这样。</p>
<p>讽刺的是，Java 垃圾回收器似乎效果很好，创建、消除大多数对象。主要的内存管理的问题都解决了，但经常是以产生严重的优化问题为代价。为了让垃圾回收器适用于所有的情形，它变成了一个复杂和难以优化的系统。为了理清关于垃圾回收器的概念，你首先要理解在JVM中内存管理是如何工作的。</p>
<h3 id="垃圾回收器如何工作的"><a href="#垃圾回收器如何工作的" class="headerlink" title="垃圾回收器如何工作的"></a>垃圾回收器如何工作的</h3><p>很多人认为垃圾回是收集并丢弃”死“对象。事实上，Java垃圾回收器恰恰相反。“活”对象被跟踪，其他的都是被指定成垃圾。正如你将要看到的，这一根本性的误解导致很多优化的问题。</p>
<p>我们从堆开始说起，堆是用来动态分配内存的一块内存区域。当应用程序在运行时，操作系统根据配置提前分配堆空间给JVM来管理。这种做法有很多重大影响：</p>
<ul>
<li><p>对象创建变得更快了，因为操作系统的全局同步对于每个对象不是必须的。一个分配请求一个内存数组的空间，同时移动偏移指针向前(图 2.1)。下一个分配在这个偏移指针开始请求下一个内存数组的空间。</p>
</li>
<li><p>当一个对象不再被使用，垃圾回收器回收底层内存，在以后的对象分配时重用这块内存。这意味着没有明确的删除内存，没有将内存交还给操作系统。</p>
</li>
</ul>
<p><img src="/images/20161019/图 2.1 - 新的对象被分配到已使用的堆的末尾.png" alt="图 2.1 : 新的对象被分配到已使用的堆的末尾"></p>
<p>所有对象都是由JVM管理，在堆空间进行分配。开发人员使用的每一个句柄都是这样处理的，包括类对象，静态变量，甚至代码本身。只要一个对象被引用，JVM就认为它是活跃的。一旦一个对象不再被引用，因此不再被应用程序代码可达，垃圾回收器就会删除它，回收不被使用的内存。这听上去简单，它引出了一个问题：谁是这颗引用树的第一个节点？</p>
<h3 id="垃圾回收-根对象－所有对象树的开始"><a href="#垃圾回收-根对象－所有对象树的开始" class="headerlink" title="垃圾回收 根对象－所有对象树的开始"></a>垃圾回收 根对象－所有对象树的开始</h3><p>每个对象树必须有一个或多个根对象。只要应用程序可达这些根对象，整棵树就是可达的。但是什么时候这些根对象被认为是可达的？这些特别的对象被称为垃圾回收的根对象(GC roots; 图2.2)总是可达的，所以</p>
<p>在Java中有4种GC 根对象</p>
<ul>
<li><p>线程栈中存活的局部变量。这不是真正的对象虚拟索引所以是不可见的。总而言之，本地变量是GC的根对象。</p>
</li>
<li><p>活跃的Java线程一直都被视为存活的对象所以是GC根对象。线程局部变量是特别需要关注的。</p>
</li>
<li><p>静态变量是被所在的类引用到。它们实际上就是GC根对象。类本身是可以被垃圾回收的，将会删除它引用所有的静态变量。当我们使用应用服务时这点很重要，一般情况是OSGi容器或者类加载器。我们将会在Problem Patterns板块讨论相关的问题。</p>
</li>
<li><p>Java本地方法引用是本地方法创建的作为JNI命令的一部分的Java对象。这样创建的对象被特别的处理，因为JVM不知道这些对象是否是本地代码创建的。这样的对象代表了特别的GC根对象构成，在Problem Patterns板块我们会检查更多的细节。</p>
</li>
</ul>
<p><img src="/images/20161019/图 2.2 - GC 根对象是那些本身被JVM引用到，阻止了其他相关的对象被垃圾回收 .png" alt="图2.2:GC 根对象是那些本身被JVM引用到，阻止了其他相关的对象被垃圾回收"></p>
<p>所以，一个简单的Java 应用程序有如下的GC 根对象。</p>
<ul>
<li>main方法的局部变量。</li>
<li>main线程</li>
<li>类中的静态变量</li>
</ul>
<h3 id="标记，清除垃圾"><a href="#标记，清除垃圾" class="headerlink" title="标记，清除垃圾"></a>标记，清除垃圾</h3><p>为了确定哪些类不再被使用，JVM 不断的适宜的运行标记清理算法。正如你可能想到的，算法明确的分两步进行：</p>
<ul>
<li>算法遍历所有的对象引用，从GC根对象开始，标记所有被找到的对象为活跃的。</li>
<li>没有标记的对象占有的堆内存会被回收，标记成释放的空间，最终清理不被使用的对象。</li>
</ul>
<p>垃圾回收目的是去除造成传统内存泄露的因素：在内存中不可达却没有删除的对象。然而，只是就原始意义来说对于内存泄露是有效的。不被使用的对象仍然可以被应用程序可达这种情况仍然存在，因为开发者会忘记去掉对象的引用。这些对象无法被垃圾回收。更糟的是，常见的内存泄露却不能被任何软件检测到(图2.3)。即使最好的分析软件也只是标注可疑的对象。</p>
<p><img src="/images/20161019/图 2.3.png" alt="图 2.3.png"></p>
<p>相关链接:<br><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/" target="_blank" rel="external">how-garbage-collection-works</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadLocal简析(2)-会有内存泄露吗]]></title>
      <url>http://Tyorofurin.github.io/2016/10/17/ThreadLocal%E7%AE%80%E6%9E%90(2)-%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%90%97/</url>
      <content type="html"><![CDATA[<h3 id="会导致内存泄露么"><a href="#会导致内存泄露么" class="headerlink" title="会导致内存泄露么?"></a>会导致内存泄露么?</h3><p>上一节我们讲到ThreadLocal的原理是：将ThreadLocal的弱引用和值包装成Entry放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。<br><img src="/images/threadlocal/ThreadLocal.png" alt="Threadlocal"></p>
<h3 id="单线程的情况"><a href="#单线程的情况" class="headerlink" title="单线程的情况"></a>单线程的情况</h3><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.tiny.work.test.threadlocal;</div><div class="line"></div><div class="line">public class ThreadLocalDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String args[]) throws InterruptedException &#123;</div><div class="line">        Thread thread =  new Thread(new MyThreadDemo(new PlexDemo()));</div><div class="line">        thread.start();</div><div class="line">        Thread.sleep(1000);</div><div class="line"></div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(100000); //等待Gc完成; 做HeapDump,查看内存回收情况</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">class MyThreadDemo implements Runnable&#123;</div><div class="line">    PlexDemo pluex;</div><div class="line"></div><div class="line">    public MyThreadDemo(PlexDemo pluex) &#123;</div><div class="line">        this.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        pluex.m_ctx.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PlexDemo&#123;</div><div class="line">    public ThreadLocal&lt;Context&gt; m_ctx = new ThreadLocal&lt;Context&gt;()&#123;</div><div class="line">        @Override</div><div class="line">        protected Context initialValue() &#123;</div><div class="line">            return new Context();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Context&#123;</div><div class="line">    char [] data = new char[1024 * 1024]; //2MB</div><div class="line"></div><div class="line">    public char[] getData() &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setData(char[] data) &#123;</div><div class="line">        this.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么要多次调用system.gc()? 这和finalize方法的策略有关系. finalize是一个特别低优先级的线程,当执行gc时,如果一个对象需要被回收,先执行它的finalize方法.这意味着,本次gc可能无法真正回收这个具有finalize方法的对象.留待下次回收. 这里多次调用system.gc正是为了给finalize留些时间.</p>
<p>在Main函数中多次调用System.gc保证需要释放的对象都被回收。在最后的Main线程等待时,我把JVM的堆Dump出来,使用MAT分析工具得到的结果如下:<br><img src="/images/threadlocal/TheadLocal-单线程堆dump.png" alt="TheadLocal-单线程堆dump"><br>从结果来看,不存在MyThreadDemo,Context的留存。JVM内存分析工具的使用请移步<a href="http://www.lightskystreet.com/2015/09/01/mat_usage/#comments" target="_blank" rel="external">MAT - Memory Analyzer Tool 使用进阶</a></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结-1"></a>总结-1</h3><p>如果没有任何强引用指向Threadlocal实例,Threadlocal将会被gc回收。</p>
<p>Thread中存在这个强引用链Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value, 当前Thread结束以后, current Thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.</p>
<p>所以,在单线程的生命周期中使用ThreadlLocal不会出现内存泄露。</p>
<h3 id="线程池中使用ThreadLocal"><a href="#线程池中使用ThreadLocal" class="headerlink" title="线程池中使用ThreadLocal"></a>线程池中使用ThreadLocal</h3><p>目前为止我们得到一个结论:只要这个线程对象被gc回收，就不会出现内存泄露。但是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。</p>
<h3 id="线程池使用ThreadLocal一定会有内存泄露"><a href="#线程池使用ThreadLocal一定会有内存泄露" class="headerlink" title="线程池使用ThreadLocal一定会有内存泄露?"></a>线程池使用ThreadLocal一定会有内存泄露?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.tiny.work.test.threadpool;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</div><div class="line">            executorService.submit(<span class="keyword">new</span> RunnabeTask(<span class="keyword">new</span> Pluex()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnabeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    Pluex m_code;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnabeTask</span><span class="params">(Pluex m_code)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.m_code = m_code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        m_code.m_ctx.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plex</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ThreadLocal&lt;Context&gt;  m_ctx = <span class="keyword">new</span> ThreadLocal&lt;Context&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Context <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Context();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> [] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//2MB</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getData() &#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">char</span>[] data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程Dump"><a href="#线程Dump" class="headerlink" title="线程Dump"></a>线程Dump</h3><p>使用jps查找运行JVM线程ID为82146，使用如下命令线程Dump<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jcmd 82146 Thread.print</div></pre></td></tr></table></figure></p>
<p>从Thread Dump结果来看，线程池里有4个线程在等待<br><img src="/images/threadlocal/ThreadLocal-线程池ThreadDump.png" alt="ThreadLocal-线程池ThreadDump"></p>
<p>堆dump前，运行如下命令，调用java.lang.System.gc().触发Full gc，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jcmd 85548 help GC.run</div><div class="line"></div><div class="line">jcmd 85548  GC.run</div></pre></td></tr></table></figure>
<p>线程池的线程运行完成后会一直保持waiting状态,主进程不会退出。运行期,内存示意图大致如下:<br><img src="/images/threadlocal/ThreadLocal-线程池内存示意图.png" alt="ThreadLocal-线程池内存示意图"></p>
<p>同时,使用下列命令做堆Dump分析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmap -dump:format=b,file=heap.bin 85548</div></pre></td></tr></table></figure></p>
<p>堆Dump的结果优MAT 分析的结果来看，Context对象仍然有8个实例没有被回收。而这8个Context对象就是ThreadLocalMap绑定的值value。</p>
<p><img src="/images/threadlocal/ThreadLocal-线程池堆Dump.png" alt="ThreadLocal-线程池堆Dump"></p>
<p>Plex.m_mtx 这个ThreadLocal对象每次创建都是不同的,所以每个线程都有两个ThreadLocalMap.Entry;<br>Thread中存在这个强引用链Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value, Thread没有退出,显示GC也无法将它们回收,所以导致了内存泄露。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadLocal简析(1)-设计原理]]></title>
      <url>http://Tyorofurin.github.io/2016/10/16/ThreadLocal%E7%AE%80%E6%9E%90(1)-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>看看JDK中的源码是这么写的：</p>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g,a user ID or Transaction ID).</p>
</blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量.这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是private static类型的，<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">用于关联一个线程</a>。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<h3 id="什么时候使用ThreadLocal？"><a href="#什么时候使用ThreadLocal？" class="headerlink" title="什么时候使用ThreadLocal？"></a>什么时候使用ThreadLocal？</h3><p>对于一个变量，你希望每个线程都有独立的对象实体时。</p>
<h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> PluexNormal pluex = <span class="keyword">new</span> PluexNormal();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyNormalThread(i, pluex)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNormalThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    PluexNormal pluex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNormalThread</span><span class="params">(<span class="keyword">int</span> index, PluexNormal pluex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + pluex.value);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            pluex.value += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + pluex.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluexNormal</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码逻辑很简单，就是每个线程加10。所有的线程共享Pluex这个对象，累加的结果值value是互相影响的。</p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程0的初始value:0</div><div class="line">线程0的累加value:10</div><div class="line">线程1的初始value:10</div><div class="line">线程1的累加value:20</div><div class="line">线程2的初始value:20</div><div class="line">线程2的累加value:30</div><div class="line">线程3的初始value:30</div><div class="line">线程3的累加value:40</div><div class="line">线程4的初始value:40</div><div class="line">线程4的累加value:50</div></pre></td></tr></table></figure></p>
<p>现在每个线程依然共享Pluex这个对象，但是我们希望每个线程互不影响的做累加。我们使用ThreadLocal来包装Pluex类中的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Pluex pluex = <span class="keyword">new</span> Pluex();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i, pluex)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    Pluex pluex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> index, Pluex pluex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + pluex.value.get());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            pluex.value.set(pluex.value.get() + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + pluex.value.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pluex</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Integer.valueOf(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程0的初始value:1</div><div class="line">线程4的初始value:1</div><div class="line">线程2的初始value:1</div><div class="line">线程3的初始value:1</div><div class="line">线程1的初始value:1</div><div class="line">线程3的累加value:11</div><div class="line">线程2的累加value:11</div><div class="line">线程4的累加value:11</div><div class="line">线程0的累加value:11</div><div class="line">线程1的累加value:11</div></pre></td></tr></table></figure>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>如果让我们自己设计ThreadLocal的话，简单的做法是ThreadLocal里放一个Map，Thread作为Key，值为绑定的对象。但是这样做是有问题的：</p>
<ul>
<li>线程销毁的时候，线程绑定的对象不能自动释放，需要显示调用ThreadLocal的方法进行释放对象。如果变量存放在Thread里，Thread回收时，变量如果没有被根对象强引用，会随着Thread一起销毁</li>
<li>还有一个问题是所有线程绑定的变量都存放在ThreadLocal中，必然会有并发访问的问题。但是线程绑定的变量只跟改线程有关，没有必要和其他线程做并发操作，而且并发会导致操作效率很低。<br>所以，我们在每个线程里有一个ThreadLocalMap对象，<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   	ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面是ThreadLocal的set方法，大致意思为</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>
<h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面是ThreadLocal的get方法，大致意思为</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e</li>
<li>如果e不为空，则返回e.value，否则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li>
</ul>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> (T)e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>实际上ThreadLocal的使用是：将ThreadLocal的弱引用和值包装成Entry放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。</p>
<p>在Threadlocal的生命周期中,都存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用.</p>
<p><img src="/images/threadlocal/ThreadLocal.png" alt="ThreadLocal"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jdk8兼容历史低JDK版本时注意的问题]]></title>
      <url>http://Tyorofurin.github.io/2016/10/16/Jdk8%E5%85%BC%E5%AE%B9%E5%8E%86%E5%8F%B2%E4%BD%8EJDK%E7%89%88%E6%9C%AC%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="JDK8-兼容历史低JDK版本时注意的问题"><a href="#JDK8-兼容历史低JDK版本时注意的问题" class="headerlink" title="JDK8 兼容历史低JDK版本时注意的问题"></a>JDK8 兼容历史低JDK版本时注意的问题</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<blockquote>
<p>虽然使用高版本的JDK可以通过指定编译source和target参数来兼容低版本JDK，但只是class文件格式上的，如果引用了高版本JRE库中某些方法一样会再低版本的JDK上报错；典型的例子就是java.util.concurrent.ConcurrentHashMap.keySet()这个方法！</p>
</blockquote>
<h3 id="异常重现"><a href="#异常重现" class="headerlink" title="异常重现"></a>异常重现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"hello"</span>, <span class="string">"world"</span>);</div><div class="line">        System.out.print(map.keySet());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用jdk1.8编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin/javac -source 1.7 -target 1.7 ConcurrentTest.java</div></pre></td></tr></table></figure></p>
<p>用jdk1.7执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java ConcurrentTest</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;</div><div class="line">	at ConcurrentTest.main(ConcurrentTest.java:8)</div></pre></td></tr></table></figure></p>
<p>jdk1.7 中,keySet方法的返回值是Set<k></k></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>jdk1.8 中,keySet方法的返回值是KeySetView<k,v><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> KeySetView&lt;K,V&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure></k,v></p>
<h3 id="造成这个问题的原因："><a href="#造成这个问题的原因：" class="headerlink" title="造成这个问题的原因："></a>造成这个问题的原因：</h3><p>我们用JDK1.8编译，keySet()会被编译成一个返回ConcurrentHashMap.KeySetView的方法，因为它是用JDK1.8的类库进行构建的。<strong>-target 1.7</strong>参数是使生成的字节码兼容JDK1.7，但是字节码中包含对JDK1.8类库的引用。所以，当你在JDK1.7上运行，使用的是JDK1.7的类库，它无法找到JDK1.8新创建的类，所以就发生了异常。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>确定项目构建的Java环境就是你希望兼容的JDK版本。构建后的字节码可以无误的运行到新版的JDK中。<br>如果你希望你的项目兼容jdk1.6，jdk1.7，jdk1.8，最好的办法就是使用jdk1.6构建项目。<br>这样做有一个问题就是，你不能使用新版本的一些特性，比如1.8的lamada表达式等功能。</p>
<h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><p><a href="http://stackoverflow.com/questions/25705259/undefined-reference-concurrenthashmap-keyset-when-building-in-java-8" target="_blank" rel="external">stackoverflow</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello-World]]></title>
      <url>http://Tyorofurin.github.io/2016/10/06/Hello-World/</url>
      <content type="html"><![CDATA[<p>青春不是年华，而是心境；青春不是桃面，丹唇，柔膝，而是深沉的意志，恢宏的想象，炽热的感情；青春是生命的源泉在不息的涌流。<br>青春气贯长虹，勇锐盖过怯懦，进取压倒苟安。如此锐气，弱冠后生有之，耳顺之年，则亦多见，年岁有加，并非垂老；理想丢弃，方堕暮年。<br>岁月悠悠，衰微只及肌肤，热忱抛却，颓唐必至灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。<br>无论年届古稀，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆深植一片追求，只要你从天上，人间追求美好，希望，欢乐，勇气和力量，你就青春永驻，风华长存。<br>一旦追求消失，锐气如同冰雪覆盖，玩世不恭，自暴自弃油然而生，即使年方二十，实已老矣。然坚持追求，你就有望在百岁高龄告别尘寰时仍觉年青。</p>
]]></content>
    </entry>
    
  
  
</search>
