<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java中的ThreadLocal简析(1)]]></title>
      <url>http://Tyorofurin.github.io/2016/10/16/Java%E4%B8%AD%E7%9A%84ThreadLocal%E7%AE%80%E6%9E%90(1)/</url>
      <content type="html"><![CDATA[<p>看看JDK中的源码是这么写的：</p>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g,a user ID or Transaction ID).</p>
</blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量.这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是private static类型的，<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">用于关联一个线程</a>。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<h3 id="什么时候使用ThreadLocal？"><a href="#什么时候使用ThreadLocal？" class="headerlink" title="什么时候使用ThreadLocal？"></a>什么时候使用ThreadLocal？</h3><p>对于一个变量，你希望每个线程都有独立的对象实体时。</p>
<h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> PluexNormal pluex = <span class="keyword">new</span> PluexNormal();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyNormalThread(i, pluex)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNormalThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    PluexNormal pluex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNormalThread</span><span class="params">(<span class="keyword">int</span> index, PluexNormal pluex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + pluex.value);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            pluex.value += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + pluex.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluexNormal</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码逻辑很简单，就是每个线程加10。所有的线程共享Pluex这个对象，累加的结果值value是互相影响的。</p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程0的初始value:0</div><div class="line">线程0的累加value:10</div><div class="line">线程1的初始value:10</div><div class="line">线程1的累加value:20</div><div class="line">线程2的初始value:20</div><div class="line">线程2的累加value:30</div><div class="line">线程3的初始value:30</div><div class="line">线程3的累加value:40</div><div class="line">线程4的初始value:40</div><div class="line">线程4的累加value:50</div></pre></td></tr></table></figure></p>
<p>现在每个线程依然共享Pluex这个对象，但是我们希望每个线程互不影响的做累加。我们使用ThreadLocal来包装Pluex类中的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Pluex pluex = <span class="keyword">new</span> Pluex();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i, pluex)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    Pluex pluex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> index, Pluex pluex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + pluex.value.get());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            pluex.value.set(pluex.value.get() + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + pluex.value.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pluex</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Integer.valueOf(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程0的初始value:1</div><div class="line">线程4的初始value:1</div><div class="line">线程2的初始value:1</div><div class="line">线程3的初始value:1</div><div class="line">线程1的初始value:1</div><div class="line">线程3的累加value:11</div><div class="line">线程2的累加value:11</div><div class="line">线程4的累加value:11</div><div class="line">线程0的累加value:11</div><div class="line">线程1的累加value:11</div></pre></td></tr></table></figure>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>如果让我们自己设计ThreadLocal的话，简单的做法是ThreadLocal里放一个Map，Thread作为Key，值为绑定的对象。但是这样做是有问题的：</p>
<ul>
<li>线程销毁的时候，线程绑定的对象不能自动释放，需要显示调用ThreadLocal的方法进行释放对象。如果变量存放在Thread里，Thread回收时，变量如果没有被根对象强引用，会随着Thread一起销毁</li>
<li>还有一个问题是所有线程绑定的变量都存放在ThreadLocal中，必然会有并发访问的问题。但是线程绑定的变量只跟改线程有关，没有必要和其他线程做并发操作，而且并发会导致操作效率很低。<br>所以，我们在每个线程里有一个ThreadLocalMap对象，<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   	ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面是ThreadLocal的set方法，大致意思为</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>
<h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面是ThreadLocal的get方法，大致意思为</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e</li>
<li>如果e不为空，则返回e.value，否则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li>
</ul>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> (T)e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>实际上ThreadLocal的使用是：将ThreadLocal的弱引用和值包装成Entry放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jdk8兼容历史低JDK版本时注意的问题]]></title>
      <url>http://Tyorofurin.github.io/2016/10/16/Jdk8%E5%85%BC%E5%AE%B9%E5%8E%86%E5%8F%B2%E4%BD%8EJDK%E7%89%88%E6%9C%AC%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="JDK8-兼容历史低JDK版本时注意的问题"><a href="#JDK8-兼容历史低JDK版本时注意的问题" class="headerlink" title="JDK8 兼容历史低JDK版本时注意的问题"></a>JDK8 兼容历史低JDK版本时注意的问题</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<blockquote>
<p>虽然使用高版本的JDK可以通过指定编译source和target参数来兼容低版本JDK，但只是class文件格式上的，如果引用了高版本JRE库中某些方法一样会再低版本的JDK上报错；典型的例子就是java.util.concurrent.ConcurrentHashMap.keySet()这个方法！</p>
</blockquote>
<h3 id="异常重现"><a href="#异常重现" class="headerlink" title="异常重现"></a>异常重现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"hello"</span>, <span class="string">"world"</span>);</div><div class="line">        System.out.print(map.keySet());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用jdk1.8编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin/javac -source 1.7 -target 1.7 ConcurrentTest.java</div></pre></td></tr></table></figure></p>
<p>用jdk1.7执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java ConcurrentTest</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;</div><div class="line">	at ConcurrentTest.main(ConcurrentTest.java:8)</div></pre></td></tr></table></figure></p>
<p>jdk1.7 中,keySet方法的返回值是Set<k></k></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>jdk1.8 中,keySet方法的返回值是KeySetView<k,v><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> KeySetView&lt;K,V&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure></k,v></p>
<h3 id="造成这个问题的原因："><a href="#造成这个问题的原因：" class="headerlink" title="造成这个问题的原因："></a>造成这个问题的原因：</h3><p>我们用JDK1.8编译，keySet()会被编译成一个返回ConcurrentHashMap.KeySetView的方法，因为它是用JDK1.8的类库进行构建的。<strong>-target 1.7</strong>参数是使生成的字节码兼容JDK1.7，但是字节码中包含对JDK1.8类库的引用。所以，当你在JDK1.7上运行，使用的是JDK1.7的类库，它无法找到JDK1.8新创建的类，所以就发生了异常。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>确定项目构建的Java环境就是你希望兼容的JDK版本。构建后的字节码可以无误的运行到新版的JDK中。<br>如果你希望你的项目兼容jdk1.6，jdk1.7，jdk1.8，最好的办法就是使用jdk1.6构建项目。<br>这样做有一个问题就是，你不能使用新版本的一些特性，比如1.8的lamada表达式等功能。</p>
<h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><p><a href="http://stackoverflow.com/questions/25705259/undefined-reference-concurrenthashmap-keyset-when-building-in-java-8" target="_blank" rel="external">stackoverflow</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello-World]]></title>
      <url>http://Tyorofurin.github.io/2016/10/06/Hello-World/</url>
      <content type="html"><![CDATA[<p>青春不是年华，而是心境；青春不是桃面，丹唇，柔膝，而是深沉的意志，恢宏的想象，炽热的感情；青春是生命的源泉在不息的涌流。<br>青春气贯长虹，勇锐盖过怯懦，进取压倒苟安。如此锐气，弱冠后生有之，耳顺之年，则亦多见，年岁有加，并非垂老；理想丢弃，方堕暮年。<br>岁月悠悠，衰微只及肌肤，热忱抛却，颓唐必至灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。<br>无论年届古稀，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆深植一片追求，只要你从天上，人间追求美好，希望，欢乐，勇气和力量，你就青春永驻，风华长存。<br>一旦追求消失，锐气如同冰雪覆盖，玩世不恭，自暴自弃油然而生，即使年方二十，实已老矣。然坚持追求，你就有望在百岁高龄告别尘寰时仍觉年青。</p>
]]></content>
    </entry>
    
  
  
</search>
