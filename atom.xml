<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tyorofurin的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Tyorofurin.github.io/"/>
  <updated>2016-10-30T14:31:58.000Z</updated>
  <id>http://Tyorofurin.github.io/</id>
  
  <author>
    <name>Tyorofurin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://Tyorofurin.github.io/2016/10/30/2016/10/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://Tyorofurin.github.io/2016/10/30/2016/10/HashMap源码分析/</id>
    <published>2016-10-30T14:31:32.000Z</published>
    <updated>2016-10-30T14:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>HashMap是Java开发人员最常使用的键值对数据类型。但是你会使用锤子，你也要知道锤子为什么能敲钉子，这样才能成为一个合格的geeker。本文基于JDK1.7源码，深入探讨HashMap的结构实现和功能原理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">TestForInit</span><span class="params">()</span></span>&#123;</div><div class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"雪国"</span>,<span class="string">"川端康成"</span>);</div><div class="line">        map.put(<span class="string">"月亮和六便士"</span>,<span class="string">"毛姆"</span>);</div><div class="line">        map.put(<span class="string">"双城记"</span>,<span class="string">"狄更斯"</span>);</div><div class="line">        map.put(<span class="string">"老人与海"</span>,<span class="string">"海明威"</span>);</div><div class="line">        map.put(<span class="string">"在路上"</span>,<span class="string">"凯鲁亚克"</span>);</div><div class="line">        map.put(<span class="string">"洛丽塔"</span>,<span class="string">"纳博科夫"</span>);</div><div class="line">        map.put(<span class="string">"苏菲的抉择"</span>,<span class="string">"斯泰伦"</span>);</div><div class="line">        map.put(<span class="string">"复活"</span>,<span class="string">"托尔斯泰"</span>);</div><div class="line">        map.put(<span class="string">"悲惨世界"</span>,<span class="string">"雨果"</span>);</div><div class="line">        map.put(<span class="string">"1984"</span>,<span class="string">"乔治·奥威尔"</span>);</div><div class="line">        map.put(<span class="string">"浮士德"</span>,<span class="string">"歌德"</span>);</div><div class="line">        map.put(<span class="string">"白夜行"</span>,<span class="string">"东野圭吾"</span>);</div><div class="line">        map.put(<span class="string">"三体"</span>,<span class="string">"刘慈欣"</span>);</div><div class="line">        map.put(<span class="string">"三体Ⅱ·黑暗森林"</span>,<span class="string">"刘慈欣"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1489192-43154934f85e8d0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HashMap存储演示.png"></p>
<h3 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h3><p>HashMap是数组+链表实现的。HashMap的基础数据结构是Entry<k,v>[] table，即hash桶数组。Entry是一个键值对，还包含两个额外的数据：</k,v></p>
<ul>
<li>指向下一个的Entry,如上图所示的，HashMap可以存储链表结构的数据。</li>
<li>代表键的hash值。Entry最终放在桶数组的那个地方，都是由键的hash值决定的。</li>
</ul>
<p>Entry<k, v="">在JDK7中的具体实现：</k,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line">        <span class="keyword">int</span> hash;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>HashMap就是使用哈希表来存储的.哈希表的冲突解决方法有开放地址法和链接地址法。HashMap使用的是链接地址法。所有hash值不同的Entry都会放在不同桶里，如果两个Entry的hash值相同，新的Entry对象插入到链表的头部。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。如果hash桶数组很大，较差的hash算法散列的也会很均匀，但是空间成本很大。如果哈说桶数组很小，再好的hash算法也会出现较大频率的冲突。所以在空间和时间的成本上作出最优的选择。</p>
<h3 id="生成桶的索引"><a href="#生成桶的索引" class="headerlink" title="生成桶的索引"></a>生成桶的索引</h3><p>这里的Hash算法本质上就是三步:</p>
<ul>
<li>取key的hashCode值</li>
<li>高位运算</li>
<li>取模运算，获取索引</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = hashSeed;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        h ^= k.hashCode();</div><div class="line"></div><div class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相同的hash值的Key在桶内位置是相同的。获取到Key的hash值后，一般来讲直接对数组长度取模就可以得到索引的位置，但是取模操作消耗还是很大的.<br>通常只有模去 2^n 才好直接用位运算做， x mod 2^n = x &amp; (2^n-1)。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1489192-914eb42de7bcb96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="位运算替代取模运算原理.png"></p>
<p>原理：我们发现当除数时2^n时，必然是100…0（n个0）,<strong>x从n位往后肯定是2^n的倍数。取模的话只要从右往左n-1位的值，所以 2^n－1 &amp; x 就是取模的结果</strong>。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>学习扩容之前，了解以下的几个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 扩容的阈值：当前容量 * 负载因子 </span></div><div class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 初始化的长度16，使用位运算保证不同平台下一定是2的指数</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div></pre></td></tr></table></figure>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; <span class="comment">//table为空表则扩张表</span></div><div class="line">            inflateTable(threshold);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="comment">//如果键为null的处理</span></div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key); <span class="comment">//取key的hashCode值</span></div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length); <span class="comment">//取模运算,获取索引</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="comment">// 如果key相同，者替换value的值。</span></div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="comment">// 添加到hash桶中</span></div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>如果实例数目size大于阈值等于threshold，并且当前索引的位置发生冲突，触发扩容机制。<br>Java是不支持动态数组的，所以在新建一个原数组两倍大小的新数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">           resize(<span class="number">2</span> * table.length);</div><div class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">           bucketIndex = indexFor(hash, table.length);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       createEntry(hash, key, value, bucketIndex);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>与此同时，由于数组的长度扩大一倍，每个实例按照之前的hash算法得到的索引位置也要发生改变，需要重新分配；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//重新计算新的索引位置</span></div><div class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">                <span class="comment">//链表的头插法</span></div><div class="line">                e.next = newTable[i];</div><div class="line">                newTable[i] = e;</div><div class="line">                e = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next,同一位置的新实例会放在链表的头部，</p>
<p>下面举个例子说明下扩容过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">TestForInit</span><span class="params">()</span></span>&#123;</div><div class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</div><div class="line">        map.put(<span class="string">"双城记"</span>,<span class="string">"狄更斯"</span>);</div><div class="line">        map.put(<span class="string">"浮士德"</span>,<span class="string">"歌德"</span>);</div><div class="line">        map.put(<span class="string">"老人与海"</span>,<span class="string">"海明威"</span>);</div><div class="line">        map.put(<span class="string">"在路上"</span>,<span class="string">"凯鲁亚克"</span>);</div><div class="line">        map.put(<span class="string">"洛丽塔"</span>,<span class="string">"纳博科夫"</span>);</div><div class="line">        map.put(<span class="string">"复活"</span>,<span class="string">"托尔斯泰"</span>);</div><div class="line">        <span class="comment">// resize</span></div><div class="line">        map.put(<span class="string">"悲惨世界"</span>,<span class="string">"雨果"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1489192-c153b6f51c2c95f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HashMap的transfer过程.png"></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>HashMap不是线程安全的，多线程的情况下最好不要使用，而使用线程安全的ConcurrentHashMap。<br>HashMap的线程安全主要体现在以下：</p>
<ul>
<li>自动调整大小的机制下，如果线程获取或者操作一个对象，Map可能使用未调整之前的数据，计算得到的索引值。实际上，数组已经扩容了，和期望的索引值不服，找不到实例存储的索引位置。</li>
<li>扩容过程中所有的实例要重新计算一遍索引，插入到新的桶中。这个过程会出现Infinite Loop</li>
</ul>
<p>证明HashMap不是线程安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSyncTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Map&lt;String , Integer&gt; resultMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> RunableTask(resultMap).start();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果是线程安全的结果应该是1W</span></div><div class="line">        System.out.print(resultMap.size());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    Map&lt;String, Integer&gt; map;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">            map.put(<span class="keyword">this</span>.getName() + i, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunableTask</span><span class="params">(Map map)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.map = map;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="键的不变性"><a href="#键的不变性" class="headerlink" title="键的不变性"></a>键的不变性</h3><p>上文提到键的hash值决定了，Entry实例存放在那个索引位置。我们推荐使用String,Integer等不可变对象作为键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_For_Immutable</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        Map&lt;MutableKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        MutableKey key = <span class="keyword">new</span> MutableKey(<span class="string">"老人与海"</span>);</div><div class="line">        map.put(key, <span class="string">"海明威"</span>);</div><div class="line"></div><div class="line">        System.out.println(map.get(key));</div><div class="line">        <span class="comment">//情况一：你已经修改了key的hash值，HashMap 会试着在错误的桶中寻找Entry对象，没有找到。</span></div><div class="line"></div><div class="line">        key.setValue(<span class="string">"三体"</span>);</div><div class="line">        System.out.println(map.get(key));</div><div class="line"></div><div class="line">		<span class="comment">//情况二：很幸运修改过的hash值得到的索引值和之前一样，Map会遍历该索引下的链表，找到相同键的Entry。判断相同的键之前，比较hash值是否一样，因为修改后的键会生成不同的哈希值（旧的哈希值被存储在记录中），那么Map没有办法在链表中找到对应的Entry对象。</span></div><div class="line"></div><div class="line">        key.setValue(<span class="string">"双城记"</span>);</div><div class="line">        System.out.println(map.get(key));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableKey</span> </span>&#123;</div><div class="line">    String value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="comment">//重写hashcode时 也要重写equals,判断key相同就是调用equals函数。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> MutableKey)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        MutableKey other = (MutableKey) obj;</div><div class="line">        <span class="keyword">if</span> (!value.equals(other.value)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutableKey</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;HashMap是Java开发人员最常使用的键值对数据类型。但是你会使用锤子，你也要知道锤子为什么能敲钉子，这样才能成为一个合格的geeker
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ArrayList工作原理及实现</title>
    <link href="http://Tyorofurin.github.io/2016/10/28/2016/10/ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://Tyorofurin.github.io/2016/10/28/2016/10/ArrayList工作原理及实现/</id>
    <published>2016-10-27T23:18:10.000Z</published>
    <updated>2016-10-28T07:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Java开发人员对于ArrayList都很熟悉，工作中几乎每天都在使用它。本文对于ArrayList内部的实现的原理进行详细的说明。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>动态数组实现了List接口。有所有的线性表的操作，允许包括null在内的所有的实例。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。(该类基本上等同于Vector，除了它不是同步的。)</p>
</blockquote>
<p>ArrayList是动态数组，简单的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">list.add(<span class="string">"克罗斯"</span>);</div><div class="line">list.add(<span class="string">"格列兹曼"</span>);</div><div class="line">list.add(<span class="string">"罗本"</span>);</div><div class="line">list.remove(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</div><div class="line">list.add(<span class="string">"test"</span>);</div><div class="line">&#125;</div><div class="line">list.add(<span class="string">"扩容"</span>);</div></pre></td></tr></table></figure>
<p>ArrayList内部是维护一个数组，add和remove操作都是对数组的操作，操作过程如下图：</p>
<p><img src="/images/2016/10/图10.28-ArrayList工作原理及实现-操作演示.png" alt="图10.28-ArrayList工作原理及实现-操作演示"></p>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要两个操作：</p>
<ul>
<li>扩容</li>
<li>新的对象放在在数组最后，计数加一</li>
</ul>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>ArrayList最重要的一点就是扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="comment">/** 扩容到原来大小的1.5倍*/</span></div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="comment">/** 扩容的容量小于需要的大小,设置为需要的大小*/</span></div><div class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        <span class="comment">/** 判断又没有超过最大的数组长度限制*/</span></div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        <span class="comment">/**将原来数组的值copy新数组中去， ArrayList的引用指向新数组*/</span></div><div class="line">        <span class="comment">/**Arrays.copyOf会新创建newCapacity大小的数组，再拷贝原数组到新的数组。如果数据量很大，重复的创建的数组，那么还是会影响效率，*/</span></div><div class="line">        <span class="comment">/**因此鼓励在合适的时候通过构造方法指定默认的capaticy大小*/</span></div><div class="line">        <span class="comment">/** minCapacity is usually close to size, so this is a win:*/</span></div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>移除此列表中指定位置上的元素。向左移动所有后续元素（将其索引减 1）。</p>
<h4 id="一个问题：如何循环删除特定的元素"><a href="#一个问题：如何循环删除特定的元素" class="headerlink" title="一个问题：如何循环删除特定的元素"></a>一个问题：如何循环删除特定的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_for_remove_one</span><span class="params">()</span></span>&#123;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"end"</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</div><div class="line">            String value = list.get(i);</div><div class="line">            <span class="keyword">if</span> (<span class="string">"test"</span>.equals(value)) &#123;</div><div class="line">                list.remove(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println((list));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[test, end]</div></pre></td></tr></table></figure></p>
<p>代码的意图是删除所有的“test”对象，但是事实上并没有达到我们的期望。下图说明了导致这种现象的原因；<br><img src="/images/2016/10/图10.28-ArrayList工作原理及实现-操作演示－索引循环删除特定对象.png" alt="图10.28-ArrayList工作原理及实现-操作演示－索引循环删除特定对象"></p>
<h4 id="如何解决-倒序删除"><a href="#如何解决-倒序删除" class="headerlink" title="如何解决- 倒序删除"></a>如何解决- 倒序删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_for_remove_one_adv</span><span class="params">()</span></span>&#123;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"end"</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            String value = list.get(i);</div><div class="line">            <span class="keyword">if</span> (<span class="string">"test"</span>.equals(value)) &#123;</div><div class="line">                list.remove(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println((list));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_for_remove_one_iterator</span><span class="params">()</span></span>&#123;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"end"</span>);</div><div class="line">        <span class="keyword">for</span> (String value: list) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"test"</span>.equals(value)) &#123;</div><div class="line">                list.remove(value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println((list));</div><div class="line">    &#125;</div><div class="line">modCount</div></pre></td></tr></table></figure>
<p>编译后反编译得到如下结果，真正运行的是如下代码，foreach语法糖隐藏了iterator,next等操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_for_remove_one_iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        ArrayList var1 = <span class="keyword">new</span> ArrayList();</div><div class="line">        var1.add(<span class="string">"test"</span>);</div><div class="line">        var1.add(<span class="string">"test"</span>);</div><div class="line">        var1.add(<span class="string">"end"</span>);</div><div class="line">        Iterator var2 = var1.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</div><div class="line">            String var3 = (String)var2.next();</div><div class="line">            <span class="keyword">if</span>(<span class="string">"test"</span>.equals(var3)) &#123;</div><div class="line">                var1.remove(var3);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(var1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>ArrayList的iterator()在AbstractList中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            checkForComodification();</div><div class="line">            <span class="keyword">int</span> i = cursor;</div><div class="line">            <span class="keyword">if</span> (i &gt;= size)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            cursor = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>迭代器内部做了修改次数的检查checkForComodification，<strong>var1.remove(var3)</strong>这个操作修改了modCount,所以才抛出了ConcurrentModificationException异常</p>
<h4 id="如何解决-显示调用迭代器进行删除"><a href="#如何解决-显示调用迭代器进行删除" class="headerlink" title="如何解决- 显示调用迭代器进行删除"></a>如何解决- 显示调用迭代器进行删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_for_remove_one_iterator_adv</span><span class="params">()</span> </span>&#123;</div><div class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"test"</span>);</div><div class="line">        list.add(<span class="string">"end"</span>);</div><div class="line">        Iterator var2 = list.iterator();</div><div class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</div><div class="line">            String var3 = (String)var2.next();</div><div class="line">            <span class="keyword">if</span>(<span class="string">"test"</span>.equals(var3)) &#123;</div><div class="line">                list.remove(var3);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(list);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="JDK关于modCount修改次数的说明"><a href="#JDK关于modCount修改次数的说明" class="headerlink" title="JDK关于modCount修改次数的说明"></a>JDK关于modCount修改次数的说明</h4><blockquote>
<p>列表结构上修改被修改的次数。结构上的修改指的是修改列表的大小，或者打乱列表，这种情况会使正在迭代的处理产生错误的结果。<br>这个字断由被iterator和listIterator方法返回的迭代器和列表迭代器使用。如果意外的改变了这个字段，此迭代器（或者列表迭代器）抛出ConcurrentModificationException异常响应next,remove,previous,set和add操作。迭代期间的面临同步修改，提供失效实时处理，而不是非确定性处理。<br>子类使用可以选择性使用这个字段。如果子类希望提供fail-fast特性的迭代器(或者列表迭代器)，则它只需在其 add(int, E) 和 remove(int) 方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。对于add和remove的单次调用，这个字段的增加不能超过1，如果实现不希望提供fail-fast特性的迭代器，该域可以被忽略。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;Java开发人员对于ArrayList都很熟悉，工作中几乎每天都在使用它。本文对于ArrayList内部的实现的原理进行详细的说明。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK" scheme="http://Tyorofurin.github.io/categories/JDK/"/>
    
    
      <category term="Java" scheme="http://Tyorofurin.github.io/tags/Java/"/>
    
      <category term="ArrayList" scheme="http://Tyorofurin.github.io/tags/ArrayList/"/>
    
      <category term="源码分析" scheme="http://Tyorofurin.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java Memory Management</title>
    <link href="http://Tyorofurin.github.io/2016/10/19/Java%20Memory%20Management/"/>
    <id>http://Tyorofurin.github.io/2016/10/19/Java Memory Management/</id>
    <published>2016-10-19T03:55:02.000Z</published>
    <updated>2016-10-19T10:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 内存管理，使用内置的垃圾回收器，是Java语言的亮点之一。它使开发者创建对象时不再担心内存的分配与回收， 因为垃圾回收器自动的回收内存来重新的使用。当消除内存泄露和其他内存相关的问题，使得用更少的代码加快开发成为可能。至少在理论上是这样。</p>
<p>讽刺的是，Java 垃圾回收器似乎效果很好，创建、消除大多数对象。主要的内存管理的问题都解决了，但经常是以产生严重的优化问题为代价。为了让垃圾回收器适用于所有的情形，它变成了一个复杂和难以优化的系统。为了理清关于垃圾回收器的概念，你首先要理解在JVM中内存管理是如何工作的。</p>
<h3 id="垃圾回收器如何工作的"><a href="#垃圾回收器如何工作的" class="headerlink" title="垃圾回收器如何工作的"></a>垃圾回收器如何工作的</h3><p>很多人认为垃圾回是收集并丢弃”死“对象。事实上，Java垃圾回收器恰恰相反。“活”对象被跟踪，其他的都是被指定成垃圾。正如你将要看到的，这一根本性的误解导致很多优化的问题。</p>
<p>我们从堆开始说起，堆是用来动态分配内存的一块内存区域。当应用程序在运行时，操作系统根据配置提前分配堆空间给JVM来管理。这种做法有很多重大影响：</p>
<ul>
<li><p>对象创建变得更快了，因为操作系统的全局同步对于每个对象不是必须的。一个分配请求一个内存数组的空间，同时移动偏移指针向前(图 2.1)。下一个分配在这个偏移指针开始请求下一个内存数组的空间。</p>
</li>
<li><p>当一个对象不再被使用，垃圾回收器回收底层内存，在以后的对象分配时重用这块内存。这意味着没有明确的删除内存，没有将内存交还给操作系统。</p>
</li>
</ul>
<p><img src="/images/20161019/图 2.1 - 新的对象被分配到已使用的堆的末尾.png" alt="图 2.1 : 新的对象被分配到已使用的堆的末尾"></p>
<p>所有对象都是由JVM管理，在堆空间进行分配。开发人员使用的每一个句柄都是这样处理的，包括类对象，静态变量，甚至代码本身。只要一个对象被引用，JVM就认为它是活跃的。一旦一个对象不再被引用，因此不再被应用程序代码可达，垃圾回收器就会删除它，回收不被使用的内存。这听上去简单，它引出了一个问题：谁是这颗引用树的第一个节点？</p>
<h3 id="垃圾回收-根对象－所有对象树的开始"><a href="#垃圾回收-根对象－所有对象树的开始" class="headerlink" title="垃圾回收 根对象－所有对象树的开始"></a>垃圾回收 根对象－所有对象树的开始</h3><p>每个对象树必须有一个或多个根对象。只要应用程序可达这些根对象，整棵树就是可达的。但是什么时候这些根对象被认为是可达的？这些特别的对象被称为垃圾回收的根对象(GC roots; 图2.2)总是可达的，所以</p>
<p>在Java中有4种GC 根对象</p>
<ul>
<li><p>线程栈中存活的局部变量。这不是真正的对象虚拟索引所以是不可见的。总而言之，本地变量是GC的根对象。</p>
</li>
<li><p>活跃的Java线程一直都被视为存活的对象所以是GC根对象。线程局部变量是特别需要关注的。</p>
</li>
<li><p>静态变量是被所在的类引用到。它们实际上就是GC根对象。类本身是可以被垃圾回收的，将会删除它引用所有的静态变量。当我们使用应用服务时这点很重要，一般情况是OSGi容器或者类加载器。我们将会在Problem Patterns板块讨论相关的问题。</p>
</li>
<li><p>Java本地方法引用是本地方法创建的作为JNI命令的一部分的Java对象。这样创建的对象被特别的处理，因为JVM不知道这些对象是否是本地代码创建的。这样的对象代表了特别的GC根对象构成，在Problem Patterns板块我们会检查更多的细节。</p>
</li>
</ul>
<p><img src="/images/20161019/图 2.2 - GC 根对象是那些本身被JVM引用到，阻止了其他相关的对象被垃圾回收 .png" alt="图2.2:GC 根对象是那些本身被JVM引用到，阻止了其他相关的对象被垃圾回收"></p>
<p>所以，一个简单的Java 应用程序有如下的GC 根对象。</p>
<ul>
<li>main方法的局部变量。</li>
<li>main线程</li>
<li>类中的静态变量</li>
</ul>
<h3 id="标记，清除垃圾"><a href="#标记，清除垃圾" class="headerlink" title="标记，清除垃圾"></a>标记，清除垃圾</h3><p>为了确定哪些类不再被使用，JVM 不断的适宜的运行标记清理算法。正如你可能想到的，算法明确的分两步进行：</p>
<ul>
<li>算法遍历所有的对象引用，从GC根对象开始，标记所有被找到的对象为活跃的。</li>
<li>没有标记的对象占有的堆内存会被回收，标记成释放的空间，最终清理不被使用的对象。</li>
</ul>
<p>垃圾回收目的是去除造成传统内存泄露的因素：在内存中不可达却没有删除的对象。然而，只是就原始意义来说对于内存泄露是有效的。不被使用的对象仍然可以被应用程序可达这种情况仍然存在，因为开发者会忘记去掉对象的引用。这些对象无法被垃圾回收。更糟的是，常见的内存泄露却不能被任何软件检测到(图2.3)。即使最好的分析软件也只是标注可疑的对象。</p>
<p><img src="/images/20161019/图 2.3.png" alt="图 2.3.png"></p>
<p>相关链接:<br><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/" target="_blank" rel="external">how-garbage-collection-works</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 内存管理，使用内置的垃圾回收器，是Java语言的亮点之一。它使开发者创建对象时不再担心内存的分配与回收， 因为垃圾回收器自动的回收内存来重新的使用。当消除内存泄露和其他内存相关的问题，使得用更少的代码加快开发成为可能。至少在理论上是这样。&lt;/p&gt;
&lt;p&gt;讽刺的是，
    
    </summary>
    
      <category term="Java" scheme="http://Tyorofurin.github.io/categories/Java/"/>
    
      <category term="外文翻译" scheme="http://Tyorofurin.github.io/categories/Java/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Memory" scheme="http://Tyorofurin.github.io/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal简析(2)-会有内存泄露吗</title>
    <link href="http://Tyorofurin.github.io/2016/10/17/ThreadLocal%E7%AE%80%E6%9E%90(2)-%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%90%97/"/>
    <id>http://Tyorofurin.github.io/2016/10/17/ThreadLocal简析(2)-会有内存泄露吗/</id>
    <published>2016-10-17T09:54:25.000Z</published>
    <updated>2016-10-18T12:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="会导致内存泄露么"><a href="#会导致内存泄露么" class="headerlink" title="会导致内存泄露么?"></a>会导致内存泄露么?</h3><p>上一节我们讲到ThreadLocal的原理是：将ThreadLocal的弱引用和值包装成Entry放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。<br><img src="/images/threadlocal/ThreadLocal.png" alt="Threadlocal"></p>
<h3 id="单线程的情况"><a href="#单线程的情况" class="headerlink" title="单线程的情况"></a>单线程的情况</h3><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.tiny.work.test.threadlocal;</div><div class="line"></div><div class="line">public class ThreadLocalDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String args[]) throws InterruptedException &#123;</div><div class="line">        Thread thread =  new Thread(new MyThreadDemo(new PlexDemo()));</div><div class="line">        thread.start();</div><div class="line">        Thread.sleep(1000);</div><div class="line"></div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(100000); //等待Gc完成; 做HeapDump,查看内存回收情况</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">class MyThreadDemo implements Runnable&#123;</div><div class="line">    PlexDemo pluex;</div><div class="line"></div><div class="line">    public MyThreadDemo(PlexDemo pluex) &#123;</div><div class="line">        this.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        pluex.m_ctx.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PlexDemo&#123;</div><div class="line">    public ThreadLocal&lt;Context&gt; m_ctx = new ThreadLocal&lt;Context&gt;()&#123;</div><div class="line">        @Override</div><div class="line">        protected Context initialValue() &#123;</div><div class="line">            return new Context();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Context&#123;</div><div class="line">    char [] data = new char[1024 * 1024]; //2MB</div><div class="line"></div><div class="line">    public char[] getData() &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setData(char[] data) &#123;</div><div class="line">        this.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么要多次调用system.gc()? 这和finalize方法的策略有关系. finalize是一个特别低优先级的线程,当执行gc时,如果一个对象需要被回收,先执行它的finalize方法.这意味着,本次gc可能无法真正回收这个具有finalize方法的对象.留待下次回收. 这里多次调用system.gc正是为了给finalize留些时间.</p>
<p>在Main函数中多次调用System.gc保证需要释放的对象都被回收。在最后的Main线程等待时,我把JVM的堆Dump出来,使用MAT分析工具得到的结果如下:<br><img src="/images/threadlocal/TheadLocal-单线程堆dump.png" alt="TheadLocal-单线程堆dump"><br>从结果来看,不存在MyThreadDemo,Context的留存。JVM内存分析工具的使用请移步<a href="http://www.lightskystreet.com/2015/09/01/mat_usage/#comments" target="_blank" rel="external">MAT - Memory Analyzer Tool 使用进阶</a></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结-1"></a>总结-1</h3><p>如果没有任何强引用指向Threadlocal实例,Threadlocal将会被gc回收。</p>
<p>Thread中存在这个强引用链Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value, 当前Thread结束以后, current Thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.</p>
<p>所以,在单线程的生命周期中使用ThreadlLocal不会出现内存泄露。</p>
<h3 id="线程池中使用ThreadLocal"><a href="#线程池中使用ThreadLocal" class="headerlink" title="线程池中使用ThreadLocal"></a>线程池中使用ThreadLocal</h3><p>目前为止我们得到一个结论:只要这个线程对象被gc回收，就不会出现内存泄露。但是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。</p>
<h3 id="线程池使用ThreadLocal一定会有内存泄露"><a href="#线程池使用ThreadLocal一定会有内存泄露" class="headerlink" title="线程池使用ThreadLocal一定会有内存泄露?"></a>线程池使用ThreadLocal一定会有内存泄露?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.tiny.work.test.threadpool;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</div><div class="line">            executorService.submit(<span class="keyword">new</span> RunnabeTask(<span class="keyword">new</span> Pluex()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnabeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    Pluex m_code;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnabeTask</span><span class="params">(Pluex m_code)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.m_code = m_code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        m_code.m_ctx.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plex</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ThreadLocal&lt;Context&gt;  m_ctx = <span class="keyword">new</span> ThreadLocal&lt;Context&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Context <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Context();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> [] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//2MB</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getData() &#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">char</span>[] data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程Dump"><a href="#线程Dump" class="headerlink" title="线程Dump"></a>线程Dump</h3><p>使用jps查找运行JVM线程ID为82146，使用如下命令线程Dump<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jcmd 82146 Thread.print</div></pre></td></tr></table></figure></p>
<p>从Thread Dump结果来看，线程池里有4个线程在等待<br><img src="/images/threadlocal/ThreadLocal-线程池ThreadDump.png" alt="ThreadLocal-线程池ThreadDump"></p>
<p>堆dump前，运行如下命令，调用java.lang.System.gc().触发Full gc，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jcmd 85548 help GC.run</div><div class="line"></div><div class="line">jcmd 85548  GC.run</div></pre></td></tr></table></figure>
<p>线程池的线程运行完成后会一直保持waiting状态,主进程不会退出。运行期,内存示意图大致如下:<br><img src="/images/threadlocal/ThreadLocal-线程池内存示意图.png" alt="ThreadLocal-线程池内存示意图"></p>
<p>同时,使用下列命令做堆Dump分析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmap -dump:format=b,file=heap.bin 85548</div></pre></td></tr></table></figure></p>
<p>堆Dump的结果优MAT 分析的结果来看，Context对象仍然有8个实例没有被回收。而这8个Context对象就是ThreadLocalMap绑定的值value。</p>
<p><img src="/images/threadlocal/ThreadLocal-线程池堆Dump.png" alt="ThreadLocal-线程池堆Dump"></p>
<p>Plex.m_mtx 这个ThreadLocal对象每次创建都是不同的,所以每个线程都有两个ThreadLocalMap.Entry;<br>Thread中存在这个强引用链Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value, Thread没有退出,显示GC也无法将它们回收,所以导致了内存泄露。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;会导致内存泄露么&quot;&gt;&lt;a href=&quot;#会导致内存泄露么&quot; class=&quot;headerlink&quot; title=&quot;会导致内存泄露么?&quot;&gt;&lt;/a&gt;会导致内存泄露么?&lt;/h3&gt;&lt;p&gt;上一节我们讲到ThreadLocal的原理是：将ThreadLocal的弱引用和值包装成
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal简析(1)-设计原理</title>
    <link href="http://Tyorofurin.github.io/2016/10/16/ThreadLocal%E7%AE%80%E6%9E%90(1)-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <id>http://Tyorofurin.github.io/2016/10/16/ThreadLocal简析(1)-设计原理/</id>
    <published>2016-10-16T13:44:56.000Z</published>
    <updated>2016-10-17T14:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>看看JDK中的源码是这么写的：</p>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g,a user ID or Transaction ID).</p>
</blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量.这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是private static类型的，<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">用于关联一个线程</a>。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<h3 id="什么时候使用ThreadLocal？"><a href="#什么时候使用ThreadLocal？" class="headerlink" title="什么时候使用ThreadLocal？"></a>什么时候使用ThreadLocal？</h3><p>对于一个变量，你希望每个线程都有独立的对象实体时。</p>
<h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> PluexNormal pluex = <span class="keyword">new</span> PluexNormal();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyNormalThread(i, pluex)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNormalThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    PluexNormal pluex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNormalThread</span><span class="params">(<span class="keyword">int</span> index, PluexNormal pluex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + pluex.value);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            pluex.value += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + pluex.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluexNormal</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码逻辑很简单，就是每个线程加10。所有的线程共享Pluex这个对象，累加的结果值value是互相影响的。</p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程0的初始value:0</div><div class="line">线程0的累加value:10</div><div class="line">线程1的初始value:10</div><div class="line">线程1的累加value:20</div><div class="line">线程2的初始value:20</div><div class="line">线程2的累加value:30</div><div class="line">线程3的初始value:30</div><div class="line">线程3的累加value:40</div><div class="line">线程4的初始value:40</div><div class="line">线程4的累加value:50</div></pre></td></tr></table></figure></p>
<p>现在每个线程依然共享Pluex这个对象，但是我们希望每个线程互不影响的做累加。我们使用ThreadLocal来包装Pluex类中的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Pluex pluex = <span class="keyword">new</span> Pluex();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i, pluex)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    Pluex pluex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> index, Pluex pluex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.pluex = pluex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的初始value:"</span> + pluex.value.get());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            pluex.value.set(pluex.value.get() + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"线程"</span> + index + <span class="string">"的累加value:"</span> + pluex.value.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pluex</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Integer.valueOf(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程0的初始value:1</div><div class="line">线程4的初始value:1</div><div class="line">线程2的初始value:1</div><div class="line">线程3的初始value:1</div><div class="line">线程1的初始value:1</div><div class="line">线程3的累加value:11</div><div class="line">线程2的累加value:11</div><div class="line">线程4的累加value:11</div><div class="line">线程0的累加value:11</div><div class="line">线程1的累加value:11</div></pre></td></tr></table></figure>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>如果让我们自己设计ThreadLocal的话，简单的做法是ThreadLocal里放一个Map，Thread作为Key，值为绑定的对象。但是这样做是有问题的：</p>
<ul>
<li>线程销毁的时候，线程绑定的对象不能自动释放，需要显示调用ThreadLocal的方法进行释放对象。如果变量存放在Thread里，Thread回收时，变量如果没有被根对象强引用，会随着Thread一起销毁</li>
<li>还有一个问题是所有线程绑定的变量都存放在ThreadLocal中，必然会有并发访问的问题。但是线程绑定的变量只跟改线程有关，没有必要和其他线程做并发操作，而且并发会导致操作效率很低。<br>所以，我们在每个线程里有一个ThreadLocalMap对象，<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   	ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面是ThreadLocal的set方法，大致意思为</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>
<h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面是ThreadLocal的get方法，大致意思为</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e</li>
<li>如果e不为空，则返回e.value，否则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li>
</ul>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> (T)e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>实际上ThreadLocal的使用是：将ThreadLocal的弱引用和值包装成Entry放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。</p>
<p>在Threadlocal的生命周期中,都存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用.</p>
<p><img src="/images/threadlocal/ThreadLocal.png" alt="ThreadLocal"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看看JDK中的源码是这么写的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class provides thread-local variables.  These variables differ from their normal counterparts in
    
    </summary>
    
      <category term="Java" scheme="http://Tyorofurin.github.io/categories/Java/"/>
    
      <category term="ThreadLocal" scheme="http://Tyorofurin.github.io/categories/Java/ThreadLocal/"/>
    
    
      <category term="Java" scheme="http://Tyorofurin.github.io/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="http://Tyorofurin.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Jdk8兼容历史低JDK版本时注意的问题</title>
    <link href="http://Tyorofurin.github.io/2016/10/16/Jdk8%E5%85%BC%E5%AE%B9%E5%8E%86%E5%8F%B2%E4%BD%8EJDK%E7%89%88%E6%9C%AC%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://Tyorofurin.github.io/2016/10/16/Jdk8兼容历史低JDK版本时注意的问题/</id>
    <published>2016-10-16T04:27:27.000Z</published>
    <updated>2016-10-16T09:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JDK8-兼容历史低JDK版本时注意的问题"><a href="#JDK8-兼容历史低JDK版本时注意的问题" class="headerlink" title="JDK8 兼容历史低JDK版本时注意的问题"></a>JDK8 兼容历史低JDK版本时注意的问题</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<blockquote>
<p>虽然使用高版本的JDK可以通过指定编译source和target参数来兼容低版本JDK，但只是class文件格式上的，如果引用了高版本JRE库中某些方法一样会再低版本的JDK上报错；典型的例子就是java.util.concurrent.ConcurrentHashMap.keySet()这个方法！</p>
</blockquote>
<h3 id="异常重现"><a href="#异常重现" class="headerlink" title="异常重现"></a>异常重现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"hello"</span>, <span class="string">"world"</span>);</div><div class="line">        System.out.print(map.keySet());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用jdk1.8编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/bin/javac -source 1.7 -target 1.7 ConcurrentTest.java</div></pre></td></tr></table></figure></p>
<p>用jdk1.7执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java ConcurrentTest</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;</div><div class="line">	at ConcurrentTest.main(ConcurrentTest.java:8)</div></pre></td></tr></table></figure></p>
<p>jdk1.7 中,keySet方法的返回值是Set<k></k></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>jdk1.8 中,keySet方法的返回值是KeySetView<k,v><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> KeySetView&lt;K,V&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure></k,v></p>
<h3 id="造成这个问题的原因："><a href="#造成这个问题的原因：" class="headerlink" title="造成这个问题的原因："></a>造成这个问题的原因：</h3><p>我们用JDK1.8编译，keySet()会被编译成一个返回ConcurrentHashMap.KeySetView的方法，因为它是用JDK1.8的类库进行构建的。<strong>-target 1.7</strong>参数是使生成的字节码兼容JDK1.7，但是字节码中包含对JDK1.8类库的引用。所以，当你在JDK1.7上运行，使用的是JDK1.7的类库，它无法找到JDK1.8新创建的类，所以就发生了异常。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>确定项目构建的Java环境就是你希望兼容的JDK版本。构建后的字节码可以无误的运行到新版的JDK中。<br>如果你希望你的项目兼容jdk1.6，jdk1.7，jdk1.8，最好的办法就是使用jdk1.6构建项目。<br>这样做有一个问题就是，你不能使用新版本的一些特性，比如1.8的lamada表达式等功能。</p>
<h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><p><a href="http://stackoverflow.com/questions/25705259/undefined-reference-concurrenthashmap-keyset-when-building-in-java-8" target="_blank" rel="external">stackoverflow</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JDK8-兼容历史低JDK版本时注意的问题&quot;&gt;&lt;a href=&quot;#JDK8-兼容历史低JDK版本时注意的问题&quot; class=&quot;headerlink&quot; title=&quot;JDK8 兼容历史低JDK版本时注意的问题&quot;&gt;&lt;/a&gt;JDK8 兼容历史低JDK版本时注意的问题&lt;/
    
    </summary>
    
    
      <category term="JDK" scheme="http://Tyorofurin.github.io/tags/JDK/"/>
    
      <category term="ConcurrentHashMap" scheme="http://Tyorofurin.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Hello-World</title>
    <link href="http://Tyorofurin.github.io/2016/10/06/Hello-World/"/>
    <id>http://Tyorofurin.github.io/2016/10/06/Hello-World/</id>
    <published>2016-10-06T04:59:00.000Z</published>
    <updated>2016-10-16T05:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>青春不是年华，而是心境；青春不是桃面，丹唇，柔膝，而是深沉的意志，恢宏的想象，炽热的感情；青春是生命的源泉在不息的涌流。<br>青春气贯长虹，勇锐盖过怯懦，进取压倒苟安。如此锐气，弱冠后生有之，耳顺之年，则亦多见，年岁有加，并非垂老；理想丢弃，方堕暮年。<br>岁月悠悠，衰微只及肌肤，热忱抛却，颓唐必至灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。<br>无论年届古稀，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆深植一片追求，只要你从天上，人间追求美好，希望，欢乐，勇气和力量，你就青春永驻，风华长存。<br>一旦追求消失，锐气如同冰雪覆盖，玩世不恭，自暴自弃油然而生，即使年方二十，实已老矣。然坚持追求，你就有望在百岁高龄告别尘寰时仍觉年青。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;青春不是年华，而是心境；青春不是桃面，丹唇，柔膝，而是深沉的意志，恢宏的想象，炽热的感情；青春是生命的源泉在不息的涌流。&lt;br&gt;青春气贯长虹，勇锐盖过怯懦，进取压倒苟安。如此锐气，弱冠后生有之，耳顺之年，则亦多见，年岁有加，并非垂老；理想丢弃，方堕暮年。&lt;br&gt;岁月悠悠，衰
    
    </summary>
    
    
  </entry>
  
</feed>
